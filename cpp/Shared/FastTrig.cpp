/*
  Copyright (c) 1999 - 2010, Vodafone Group Services Ltd
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  * Neither the name of the Vodafone Group Services Ltd nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Fast trignometry functions.
 * These are usually integer functions that are faster than their 
 * more exact floating point counterparts. 
 */

#include "arch.h"
#include "FastTrig.h"
#include "ArchFastMath.h"

namespace isab {



   /**
    * Atan-table used by lib_angle_teta2_int()
    *
    * A table of atan function values in the interval 0..1.
    * The values are in 256:th of a full circle.
    *
    * Generated by the matlab command
    *   round((atan(0:(1/64):1) /(2*pi) * 256))
    */
   const uint8 FastTrig::angletable[] = {
       0,     1,     1,     2,     3,     3,     4,     4,     5,     6,     6,     7,
       8,     8,     9,     9,    10,    11,    11,    12,    12,    13,    13,    14,
      15,    15,    16,    16,    17,    17,    18,    18,    19,    19,    20,    20,
      21,    21,    22,    22,    23,    23,    24,    24,    25,    25,    25,    26,
      26,    27,    27,    27,    28,    28,    29,    29,    29,    30,    30,    30,
      31,    31,    31,    32,    32
   };


   /**
    * Trigometric functions for the "256-parts" circle
    * For use in fix-decimalpoint calculations, with
    * 16 bit decimal part and 16 bit integer part.
    *
    * Table generated with the following code and then pasted above...
    * By using  0xffff instead of 0x10000 are we saving one bit
    *
    *    void main() {
    *      int i, cos_val_int;
    *      printf("  0xffff,\n");
    *      for (i=1; i <=64; i++)  {
    *        cos_val_int = cos( (i * PI * 2) / 256) * 65536.0;
    *        printf("  0x%x,\n", cos_val_int);
    *      }
    *    }
    *
    */
   const uint16 FastTrig::shared_trig_sin_table[] = {
      0xffff, 0xffec, 0xffb1, 0xff4e,
      0xfec4, 0xfe13, 0xfd3a, 0xfc3b,
      0xfb14, 0xf9c7, 0xf853, 0xf6ba,
      0xf4fa, 0xf314, 0xf109, 0xeed8,
      0xec83, 0xea09, 0xe76b, 0xe4aa,
      0xe1c5, 0xdebe, 0xdb94, 0xd848,
      0xd4db, 0xd14d, 0xcd9f, 0xc9d1,
      0xc5e4, 0xc1d8, 0xbdae, 0xb968,
      0xb504, 0xb085, 0xabeb, 0xa736,
      0xa267, 0x9d7f, 0x987f, 0x9368,
      0x8e39, 0x88f5, 0x839c, 0x7e2e,
      0x78ad, 0x7319, 0x6d74, 0x67bd,
      0x61f7, 0x5c22, 0x563e, 0x504d,
      0x4a50, 0x4447, 0x3e33, 0x3817,
      0x31f1, 0x2bc4, 0x2590, 0x1f56,
      0x1917, 0x12d5, 0xc8f, 0x648,
      0x0
   };

   /**
    * This table, used in the 
    * shared_trig_sec256() function,
    * has 8 decimal bits and 8 integer bits.
    *
    * Table above generated with the following code:
    * We let 0xfff be the maximal value. It is as close to infinity we
    * need to be anyway.
    *
    *    #define min(a,b) (((a)<(b))?(a):(b))
    *    int main(int argc, char** argv)
    *    {
    *       int i;
    *       unsigned int sec_val_int;
    *       for (i=1; i <=64; i++)  {
    *          sec_val_int = floor(min((1/cos((i* PI * 2) / 256)) * 0x100,0xffff));
    *          printf("  %0#6x,\n", sec_val_int);
    *       }
    *       return 0;
    *    }
    *
    */
   const uint16 FastTrig::shared_trig_sec_table[] = {
      0x0100,0x0100,0x0100,0x0100,
      0x0101,0x0101,0x0102,0x0103,
      0x0105,0x0106,0x0107,0x0109,
      0x010b,0x010d,0x010f,0x0112,
      0x0115,0x0118,0x011b,0x011e,
      0x0122,0x0126,0x012a,0x012f,
      0x0133,0x0139,0x013e,0x0144,
      0x014b,0x0152,0x0159,0x0161,
      0x016a,0x0173,0x017d,0x0187,
      0x0193,0x01a0,0x01ad,0x01bc,
      0x01cc,0x01de,0x01f1,0x0207,
      0x021f,0x0239,0x0256,0x0277,
      0x029c,0x02c7,0x02f7,0x0330,
      0x0371,0x03bf,0x041d,0x0490,
      0x0520,0x05d9,0x06d0,0x082b,
      0x0a33,0x0d97,0x1461,0x28bf,
      0xffff
   };


   uint8 FastTrig::angleTheta2int(int16 dx, int16 dy)
      {
         int16 tmp;
         int8 flipx=0, flipy=0, flipdiag=0;
         uint8 angle;
#ifdef HAS_UINT16_UINT16_DIV
         uint8 remaining_shifts;
#else
         uint32 tableindex;
#endif

         if (dx<0) {
            if (dx==-32768)
               dx=32767;
            else
               dx=-dx;
            flipx=1;
         }
         if (dy<0) {
            if (dy==-32768)
               dy=32767;
            else
               dy=-dy;
            flipy=1;
         }
         if (dx>dy) {
            tmp=dx;
            dx=dy;
            dy=tmp;
            flipdiag=1;
         }

         /* We now have dx>=0, dy>=0, dy>=dx.
          * Look up the fraction dx/dy in a table. From the above we know
          * that 
          *     0 <= (dx/dy) <= 1.
          * By multiplying dx with 64 (optimized to a shift by the
          * compiler) and then performing an integer division we get
          *     0 <= ((dx*64 / dy) <= 64
          * This value is used to lookup a table of 65 entries.
          *
          * To handle the case of dx*64>0xffff we move dx into a 
          * uint32. This is jsut as fast on h8300h, since we can only 
          * use uint32/uint16 and don't have a uint16/uint16 in the
          * hardware. 
          *
          * An alternate implementation would shift dx left until we 
          * hit the most significant bit, then we shift dy right the
          * remaining bits. dx*64>0xffff is equivalent to dx>0x03ff
          */
#ifndef HAS_UINT16_UINT16_DIV
         tableindex = fast_div_uint32_uint16_to_uint16(
               ((uint32)dx)*64, dy );
         tableindex=tableindex & 0xffff;
         angle=angletable[ tableindex ];
#else
         if (!(dx & 0xfc00)) {
            dx=dx<<6;
         } else {
            remaining_shifts=6;
            while (remaining_shifts && !(dx & 0x8000)) {
               dx=dx<<1;
               remaining_shifts--;
            }
            while (remaining_shifts) {
               dy=dy>>1;
               remaining_shifts--;
            }
         }
         angle=angletable[ dx / dy ];
#endif

         /* Undo the reflections */
         if (flipdiag) {
            angle=64-angle;
         }

         if (flipy) {
            angle=128-angle;
         }

         if (flipx) {
            angle=(uint8)((uint8)(0)-angle);
         }

         return angle;
      }





   uint8 FastTrig::angleTheta2float(float dx, float dy)
   {
      float tmp;
      int8 flipx=0, flipy=0, flipdiag=0;
      uint8 angle;

      if (dx<0) {
         dx=-dx;
         flipx=1;
      }
      if (dy<0) {
         dy=-dy;
         flipy=1;
      }
      if (dx>dy) {
         tmp=dx;
         dx=dy;
         dy=tmp;
         flipdiag=1;
      }

      if (dy == 0) {
         return 0;
      }

      /* See angleTeta2int for a description of this */
      angle=angletable[ (uint8)(dx*64/dy) ];

      /* Undo the reflections */
      if (flipdiag) {
         angle=64-angle;
      }

      if (flipy) {
         angle=128-angle;
      }

      if (flipx) {
         angle=(uint8)((uint8)(0)-angle);
      }

      return angle;
   }


   
   int32 FastTrig::cos256(int16 j)
   {
      /* Make sure that j is in [0,255] */
      j &= 255;

      /* Return the correct value */
      if (j < 64) {
         return (shared_trig_sin_table[j] & 0x0000ffff);
      } else if (j < 128) {
         return (~shared_trig_sin_table[-j+128] | 0xffff0000);
      } else if (j < 192) {
         return (~shared_trig_sin_table[j-128] | 0xffff0000);
      } else {
         return (shared_trig_sin_table[-j+256] & 0x0000ffff);
      }
   }


   int32 FastTrig::sin256(int16 j)
   {
      /* Make sure that j is in [0,255] */
      j &= 255;

      /* Return the correct cos-value */
      if (j < 64) {
         return (shared_trig_sin_table[-j+64] & 0x0000ffff);
      } else if (j < 128) {
         return (shared_trig_sin_table[j-64] & 0x0000ffff);
      } else if (j < 192) {
         return (~shared_trig_sin_table[-j+192] | 0xffff0000);
      } else {
         return (~shared_trig_sin_table[j-192] | 0xffff0000);
      }
   }


   int32 FastTrig::sec256(int16 j)
   {
      j &= 0xff;

      if(j<64){
         return(((uint32)shared_trig_sec_table[j] << 8) & 0x00ffff00);
      }
      else if(j<128){
         return(~((uint32)shared_trig_sec_table[128-j] << 8) | 0xff000000);
      }
      else if(j<192){
         return(~((uint32)shared_trig_sec_table[128-(256-j)] << 8) | 0xff000000);
      }
      else{
         return(((uint32)shared_trig_sec_table[-j+256] << 8) & 0x00ffff00);
      }
   }


}


